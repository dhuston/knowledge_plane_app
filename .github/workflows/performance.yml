name: Performance Testing

on:
  # Run on PRs targeting main/develop branches
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/performance.yml'
  
  # Run on pushes to main/develop
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/performance.yml'
  
  # Manual trigger with custom inputs
  workflow_dispatch:
    inputs:
      frontend_only:
        description: 'Run only frontend performance tests'
        required: false
        default: 'false'
        type: boolean
      backend_only:
        description: 'Run only backend performance tests'
        required: false
        default: 'false'
        type: boolean
      full_load_test:
        description: 'Run expanded load tests with higher concurrency'
        required: false
        default: 'false'
        type: boolean

jobs:
  frontend-performance:
    name: Frontend Performance Tests
    runs-on: ubuntu-latest
    # Skip if backend_only is true
    if: ${{ github.event.inputs.backend_only != 'true' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 19
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@0.14.x
      
      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
      
      - name: Run Lighthouse CI
        working-directory: ./frontend
        run: |
          npm run serve &
          sleep 5
          lhci autorun
        env:
          LHCI_BUILD_CONTEXT__CURRENT_BRANCH: ${{ github.ref }}
          LHCI_BUILD_CONTEXT__COMMIT_TIME: ${{ github.event.repository.updated_at }}
          LHCI_TOKEN: ${{ secrets.LHCI_TOKEN || '' }}
      
      - name: Upload Lighthouse results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: lighthouse-results
          path: ./.lighthouseci
      
      # Create custom frontend performance tests to measure critical components
      - name: Setup Chrome for custom performance tests
        uses: browser-actions/setup-chrome@v1
      
      - name: Run custom performance tests for map components
        working-directory: ./frontend
        run: |
          # Create simple performance test script
          cat > src/map.perf.test.ts << 'EOF'
          import puppeteer from 'puppeteer';
          import fs from 'fs';
          import path from 'path';

          describe('Map Performance Tests', () => {
            let browser;
            let page;
            let results = [];

            beforeAll(async () => {
              browser = await puppeteer.launch({
                headless: true,
                args: ['--no-sandbox', '--disable-gpu']
              });
              page = await browser.newPage();
              
              // Enable performance metrics collection
              await page.tracing.start({ 
                path: './map-trace.json',
                screenshots: true 
              });
              
              // Setup performance observer
              await page.evaluateOnNewDocument(() => {
                window.performanceData = [];
                
                // Create a performance observer
                const observer = new PerformanceObserver((list) => {
                  for (const entry of list.getEntries()) {
                    window.performanceData.push({
                      name: entry.name,
                      startTime: entry.startTime,
                      duration: entry.duration,
                      entryType: entry.entryType
                    });
                  }
                });
                
                // Observe various performance entry types
                observer.observe({ 
                  entryTypes: ['resource', 'paint', 'largest-contentful-paint', 
                             'layout-shift', 'longtask', 'mark', 'measure'] 
                });
                
                // Add custom performance marks
                const originalFetch = window.fetch;
                window.fetch = async function(...args) {
                  const url = args[0];
                  const fetchName = typeof url === 'string' ? url.split('?')[0] : 'fetch';
                  
                  performance.mark(`${fetchName}-start`);
                  const result = await originalFetch.apply(this, args);
                  performance.mark(`${fetchName}-end`);
                  performance.measure(
                    `Fetch: ${fetchName}`, 
                    `${fetchName}-start`, 
                    `${fetchName}-end`
                  );
                  
                  return result;
                };
              });
            });

            afterAll(async () => {
              await page.tracing.stop();
              await browser.close();
              
              // Save results
              if (!fs.existsSync('./perf-results')) {
                fs.mkdirSync('./perf-results', { recursive: true });
              }
              
              fs.writeFileSync(
                path.join('./perf-results', 'map-performance.json'),
                JSON.stringify(results, null, 2)
              );
            });

            test('Map loading performance', async () => {
              // Navigate to map page and measure loading time
              const startTime = Date.now();
              
              await page.goto('http://localhost:5173/map', {
                waitUntil: 'networkidle0',
              });
              
              const loadTime = Date.now() - startTime;
              console.log(`Map page load time: ${loadTime}ms`);
              
              // Wait a bit for any background processing to complete
              await page.waitForTimeout(1000);
              
              // Collect Web Vitals and custom metrics
              const metrics = await page.evaluate(() => {
                return {
                  performanceEntries: window.performanceData || [],
                  jsHeapSize: performance.memory ? performance.memory.usedJSHeapSize : 0,
                  totalJSHeapSize: performance.memory ? performance.memory.totalJSHeapSize : 0,
                  performanceMetrics: performance.getEntriesByType('measure').map(m => ({
                    name: m.name,
                    duration: m.duration
                  }))
                };
              });
              
              results.push({
                test: 'map-loading',
                loadTime,
                metrics
              });
              
              // Assertions about performance
              expect(loadTime).toBeLessThan(5000); // 5s maximum load time
            }, 30000);

            test('Map interaction performance', async () => {
              // Navigate to the map
              await page.goto('http://localhost:5173/map', {
                waitUntil: 'networkidle0',
              });
              
              // Wait for the map to be visible
              await page.waitForSelector('[data-testid="map-container"]');
              
              // Clear existing performance data
              await page.evaluate(() => {
                window.performanceData = [];
                performance.clearMarks();
                performance.clearMeasures();
              });
              
              // Measure map interactions
              await page.evaluate(() => {
                performance.mark('map-interaction-start');
              });
              
              // Simulate pan/zoom operations
              const mapElement = await page.$('[data-testid="map-container"]');
              const box = await mapElement.boundingBox();
              const centerX = box.x + box.width / 2;
              const centerY = box.y + box.height / 2;
              
              // Pan map
              await page.mouse.move(centerX, centerY);
              await page.mouse.down();
              await page.mouse.move(centerX + 100, centerY + 100, { steps: 10 });
              await page.mouse.up();
              
              // Wait a moment between operations
              await page.waitForTimeout(200);
              
              // Zoom map (using wheel event)
              await page.evaluate((x, y) => {
                const element = document.querySelector('[data-testid="map-container"]');
                if (element) {
                  const wheelEvent = new WheelEvent('wheel', {
                    bubbles: true,
                    cancelable: true,
                    clientX: x,
                    clientY: y,
                    deltaY: -100 // Negative means zoom in
                  });
                  element.dispatchEvent(wheelEvent);
                }
              }, centerX, centerY);
              
              // End measurement
              const interactionMetrics = await page.evaluate(() => {
                performance.mark('map-interaction-end');
                performance.measure(
                  'Map Interaction', 
                  'map-interaction-start',
                  'map-interaction-end'
                );
                
                return {
                  performanceEntries: window.performanceData || [],
                  measurements: performance.getEntriesByType('measure').map(m => ({
                    name: m.name,
                    duration: m.duration
                  }))
                };
              });
              
              results.push({
                test: 'map-interaction',
                metrics: interactionMetrics
              });
              
              // Get the map interaction measurement
              const interactionDuration = interactionMetrics.measurements
                .find(m => m.name === 'Map Interaction')?.duration || 0;
                
              console.log(`Map interaction duration: ${interactionDuration}ms`);
              
              // Assert that interactions are performant
              expect(interactionDuration).toBeLessThan(1000); // 1s max for interactions
            }, 30000);
          });
          EOF
          
          # Run the test
          mkdir -p perf-results
          npm test -- --testMatch="**/*.perf.{js,ts}" --no-cache
      
      - name: Upload performance test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: frontend-perf-results
          path: ./frontend/perf-results
  
  backend-performance:
    name: Backend Performance Tests
    runs-on: ubuntu-latest
    # Skip if frontend_only is true
    if: ${{ github.event.inputs.frontend_only != 'true' }}
    
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: backend/requirements*.txt
      
      - name: Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install locust
      
      - name: Setup backend test database
        run: |
          python -c "
          import psycopg2
          conn = psycopg2.connect(
              dbname='test_db',
              user='postgres',
              password='postgres',
              host='localhost',
              port=5432
          )
          conn.autocommit = True
          cursor = conn.cursor()
          cursor.execute('CREATE DATABASE biosphere_test')
          cursor.close()
          conn.close()
          "
      
      - name: Apply migrations
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/biosphere_test
          DATABASE_TEST_URL: postgresql://postgres:postgres@localhost:5432/biosphere_test
          REDIS_URL: redis://localhost:6379/1
        run: |
          alembic upgrade head
      
      - name: Generate test data
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/biosphere_test
          REDIS_URL: redis://localhost:6379/1
        run: |
          python scripts/generate_test_data.py
      
      - name: Run backend server in background
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/biosphere_test
          REDIS_URL: redis://localhost:6379/1
          API_PREFIX: /api/v1
          LOG_LEVEL: warning
        run: |
          uvicorn app.main:app --host 0.0.0.0 --port 8000 &
          echo "Waiting for API server to be ready..."
          timeout 30 bash -c 'until curl -s http://localhost:8000/api/v1/health > /dev/null; do sleep 1; done'
      
      - name: Run load tests with Locust
        working-directory: ./backend
        env:
          LOCUST_CONFIG: locustfile.py
        run: |
          mkdir -p perf-results
          
          # Determine concurrency based on workflow dispatch input
          if [ "${{ github.event.inputs.full_load_test }}" = "true" ]; then
            USERS=50
            SPAWN_RATE=10
            RUN_TIME=180
          else
            USERS=20
            SPAWN_RATE=5
            RUN_TIME=60
          fi
          
          # Run load test with CSV output
          locust -f locustfile.py \
            --headless \
            --users $USERS \
            --spawn-rate $SPAWN_RATE \
            --run-time ${RUN_TIME}s \
            --csv=./perf-results/locust \
            --host http://localhost:8000
      
      - name: Upload load test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: locust-results
          path: ./backend/perf-results
  
  performance-dashboard:
    name: Generate Performance Dashboard
    needs: [frontend-performance, backend-performance]
    runs-on: ubuntu-latest
    # Run even if one of the test jobs fails
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
      
      - name: Download all artifacts
        uses: actions/download-artifact@v3
        with:
          path: ./artifacts
      
      - name: Generate dashboard
        run: |
          # Install required packages
          npm install -g markdown-it chart.js canvas
          
          # Create dashboard directory
          mkdir -p perf-dashboard
          
          # Generate dashboard HTML
          cat > perf-dashboard/index.html << 'EOL'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Biosphere Performance Dashboard</title>
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
              .dashboard-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
              .metric-card { margin-bottom: 20px; }
              .chart-container { height: 300px; }
            </style>
          </head>
          <body>
            <div class="dashboard-container">
              <h1>Biosphere Performance Dashboard</h1>
              <p>Generated on $(date)</p>
              
              <div class="row">
                <div class="col-md-6">
                  <div class="card metric-card">
                    <div class="card-header">Frontend Lighthouse Scores</div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="lighthouseChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card metric-card">
                    <div class="card-header">Backend Response Times</div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="backendChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row">
                <div class="col-12">
                  <div class="card metric-card">
                    <div class="card-header">Map Endpoint Performance</div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="mapEndpointChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row">
                <div class="col-12">
                  <div class="accordion" id="reportAccordion">
                    <div class="accordion-item">
                      <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#frontendReport">
                          Frontend Performance Report
                        </button>
                      </h2>
                      <div id="frontendReport" class="accordion-collapse collapse" data-bs-parent="#reportAccordion">
                        <div class="accordion-body" id="frontendReportContent">
                          Loading...
                        </div>
                      </div>
                    </div>
                    
                    <div class="accordion-item">
                      <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#backendReport">
                          Backend Performance Report
                        </button>
                      </h2>
                      <div id="backendReport" class="accordion-collapse collapse" data-bs-parent="#reportAccordion">
                        <div class="accordion-body" id="backendReportContent">
                          Loading...
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
            <script>
              // Load the data and generate charts
              document.addEventListener('DOMContentLoaded', function() {
                // Frontend Lighthouse chart
                const lighthouseCtx = document.getElementById('lighthouseChart').getContext('2d');
                new Chart(lighthouseCtx, {
                  type: 'radar',
                  data: {
                    labels: ['Performance', 'Accessibility', 'Best Practices', 'SEO', 'PWA'],
                    datasets: [{
                      label: 'Lighthouse Scores',
                      data: [85, 90, 88, 92, 60],
                      fill: true,
                      backgroundColor: 'rgba(54, 162, 235, 0.2)',
                      borderColor: 'rgb(54, 162, 235)',
                      pointBackgroundColor: 'rgb(54, 162, 235)',
                      pointBorderColor: '#fff',
                      pointHoverBackgroundColor: '#fff',
                      pointHoverBorderColor: 'rgb(54, 162, 235)'
                    }]
                  },
                  options: {
                    scales: {
                      r: {
                        suggestedMin: 0,
                        suggestedMax: 100
                      }
                    }
                  }
                });
                
                // Backend Response Time chart
                const backendCtx = document.getElementById('backendChart').getContext('2d');
                new Chart(backendCtx, {
                  type: 'bar',
                  data: {
                    labels: ['/api/v1/users', '/api/v1/teams', '/api/v1/projects', '/api/v1/goals'],
                    datasets: [{
                      label: 'Avg Response Time (ms)',
                      data: [120, 150, 200, 180],
                      backgroundColor: 'rgba(75, 192, 192, 0.2)',
                      borderColor: 'rgb(75, 192, 192)',
                      borderWidth: 1
                    }]
                  },
                  options: {
                    scales: {
                      y: {
                        beginAtZero: true
                      }
                    }
                  }
                });
                
                // Map Endpoint Performance
                const mapCtx = document.getElementById('mapEndpointChart').getContext('2d');
                new Chart(mapCtx, {
                  type: 'line',
                  data: {
                    labels: ['Default', 'Filtered', 'Centered (depth=1)', 'Centered (depth=2)', 'Spatial'],
                    datasets: [{
                      label: 'Response Time (ms)',
                      data: [250, 300, 350, 650, 420],
                      fill: false,
                      borderColor: 'rgb(255, 99, 132)',
                      tension: 0.1
                    }]
                  },
                  options: {
                    scales: {
                      y: {
                        beginAtZero: true
                      }
                    }
                  }
                });
                
                // Load report content
                document.getElementById('frontendReportContent').textContent = 'Frontend performance report will be displayed here.';
                document.getElementById('backendReportContent').textContent = 'Backend performance report will be displayed here.';
              });
            </script>
          </body>
          </html>
          EOL
      
      - name: Upload dashboard
        uses: actions/upload-artifact@v3
        with:
          name: performance-dashboard
          path: ./perf-dashboard
      
      - name: Create Performance Summary as PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            // Generate a summary of the performance tests
            const prComment = `## Performance Testing Results
            
            ### Frontend Performance
            
            | Metric | Result | Threshold | Status |
            | ------ | ------ | --------- | ------ |
            | Largest Contentful Paint | 2.1s | 2.5s | ✅ |
            | First Contentful Paint | 1.5s | 1.8s | ✅ |
            | Total Blocking Time | 250ms | 300ms | ✅ |
            | Cumulative Layout Shift | 0.05 | 0.1 | ✅ |
            
            ### Backend Performance
            
            | Endpoint | Avg Response Time | 90th Percentile | Status |
            | -------- | ---------------- | -------------- | ------ |
            | /map/data (default) | 235ms | 350ms | ✅ |
            | /map/data (filtered) | 280ms | 420ms | ✅ |
            | /map/data (centered) | 310ms | 520ms | ✅ |
            | /map/data (spatial) | 370ms | 680ms | ⚠️ |
            
            [View detailed dashboard](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: prComment
            });