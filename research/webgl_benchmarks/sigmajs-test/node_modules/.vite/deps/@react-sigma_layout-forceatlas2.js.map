{
  "version": 3,
  "sources": ["../../graphology-utils/getters.js", "../../graphology-layout-forceatlas2/iterate.js", "../../graphology-layout-forceatlas2/helpers.js", "../../graphology-layout-forceatlas2/defaults.js", "../../graphology-layout-forceatlas2/index.js", "../../graphology-layout-forceatlas2/webworker.js", "../../graphology-layout-forceatlas2/worker.js", "../../@react-sigma/layout-core/src/useLayoutFactory.ts", "../../@react-sigma/layout-core/src/useWorkerLayoutFactory.ts", "../../@react-sigma/layout-core/src/assets/icons/play-solid.svg", "../../@react-sigma/layout-core/src/assets/icons/stop-solid.svg", "../../@react-sigma/layout-core/src/WorkerLayoutControl.tsx", "../../@react-sigma/layout-forceatlas2/src/useLayoutForceAtlas2.ts", "../../@react-sigma/layout-forceatlas2/src/useWorkerLayoutForceAtlas2.ts", "../../@react-sigma/layout-forceatlas2/src/LayoutForceAtlas2Control.tsx"],
  "sourcesContent": ["/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n", "/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n", "/**\n * Graphology ForceAtlas2 Helpers\n * ===============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexports.assign = function (target) {\n  target = target || {};\n\n  var objects = Array.prototype.slice.call(arguments).slice(1),\n    i,\n    k,\n    l;\n\n  for (i = 0, l = objects.length; i < l; i++) {\n    if (!objects[i]) continue;\n\n    for (k in objects[i]) target[k] = objects[i][k];\n  }\n\n  return target;\n};\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if ('linLogMode' in settings && typeof settings.linLogMode !== 'boolean')\n    return {message: 'the `linLogMode` setting should be a boolean.'};\n\n  if (\n    'outboundAttractionDistribution' in settings &&\n    typeof settings.outboundAttractionDistribution !== 'boolean'\n  )\n    return {\n      message:\n        'the `outboundAttractionDistribution` setting should be a boolean.'\n    };\n\n  if ('adjustSizes' in settings && typeof settings.adjustSizes !== 'boolean')\n    return {message: 'the `adjustSizes` setting should be a boolean.'};\n\n  if (\n    'edgeWeightInfluence' in settings &&\n    typeof settings.edgeWeightInfluence !== 'number'\n  )\n    return {\n      message: 'the `edgeWeightInfluence` setting should be a number.'\n    };\n\n  if (\n    'scalingRatio' in settings &&\n    !(typeof settings.scalingRatio === 'number' && settings.scalingRatio >= 0)\n  )\n    return {message: 'the `scalingRatio` setting should be a number >= 0.'};\n\n  if (\n    'strongGravityMode' in settings &&\n    typeof settings.strongGravityMode !== 'boolean'\n  )\n    return {message: 'the `strongGravityMode` setting should be a boolean.'};\n\n  if (\n    'gravity' in settings &&\n    !(typeof settings.gravity === 'number' && settings.gravity >= 0)\n  )\n    return {message: 'the `gravity` setting should be a number >= 0.'};\n\n  if (\n    'slowDown' in settings &&\n    !(typeof settings.slowDown === 'number' || settings.slowDown >= 0)\n  )\n    return {message: 'the `slowDown` setting should be a number >= 0.'};\n\n  if (\n    'barnesHutOptimize' in settings &&\n    typeof settings.barnesHutOptimize !== 'boolean'\n  )\n    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};\n\n  if (\n    'barnesHutTheta' in settings &&\n    !(\n      typeof settings.barnesHutTheta === 'number' &&\n      settings.barnesHutTheta >= 0\n    )\n  )\n    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for both nodes & edges of the given graph.\n *\n * @param  {Graph}    graph         - Target graph.\n * @param  {function} getEdgeWeight - Edge weight getter function.\n * @return {object}                 - Both matrices.\n */\nexports.graphToByteArrays = function (graph, getEdgeWeight) {\n  var order = graph.order;\n  var size = graph.size;\n  var index = {};\n  var j;\n\n  // NOTE: float32 could lead to issues if edge array needs to index large\n  // number of nodes.\n  var NodeMatrix = new Float32Array(order * PPN);\n  var EdgeMatrix = new Float32Array(size * PPE);\n\n  // Iterate through nodes\n  j = 0;\n  graph.forEachNode(function (node, attr) {\n    // Node index\n    index[node] = j;\n\n    // Populating byte array\n    NodeMatrix[j] = attr.x;\n    NodeMatrix[j + 1] = attr.y;\n    NodeMatrix[j + 2] = 0; // dx\n    NodeMatrix[j + 3] = 0; // dy\n    NodeMatrix[j + 4] = 0; // old_dx\n    NodeMatrix[j + 5] = 0; // old_dy\n    NodeMatrix[j + 6] = 1; // mass\n    NodeMatrix[j + 7] = 1; // convergence\n    NodeMatrix[j + 8] = attr.size || 1;\n    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;\n    j += PPN;\n  });\n\n  // Iterate through edges\n  j = 0;\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    var sj = index[source];\n    var tj = index[target];\n\n    var weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n\n    // Incrementing mass to be a node's weighted degree\n    NodeMatrix[sj + 6] += weight;\n    NodeMatrix[tj + 6] += weight;\n\n    // Populating byte array\n    EdgeMatrix[j] = sj;\n    EdgeMatrix[j + 1] = tj;\n    EdgeMatrix[j + 2] = weight;\n    j += PPE;\n  });\n\n  return {\n    nodes: NodeMatrix,\n    edges: EdgeMatrix\n  };\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}         graph         - Target graph.\n * @param {Float32Array}  NodeMatrix    - Node matrix.\n * @param {function|null} outputReducer - A node reducer.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var i = 0;\n\n  graph.updateEachNodeAttributes(function (node, attr) {\n    attr.x = NodeMatrix[i];\n    attr.y = NodeMatrix[i + 1];\n\n    i += PPN;\n\n    return outputReducer ? outputReducer(node, attr) : attr;\n  });\n};\n\n/**\n * Function reading the positions (only) from the graph, to write them in the matrix.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n */\nexports.readGraphPositions = function (graph, NodeMatrix) {\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    NodeMatrix[i] = attr.x;\n    NodeMatrix[i + 1] = attr.y;\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}         graph         - Target graph.\n * @param  {Float32Array}  NodeMatrix    - Node matrix.\n * @param  {function|null} outputReducer - A nodes reducer.\n * @return {object}                      - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var nodes = graph.nodes(),\n    positions = {};\n\n  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\n    if (outputReducer) {\n      var newAttr = Object.assign({}, graph.getNodeAttributes(nodes[j]));\n      newAttr.x = NodeMatrix[i];\n      newAttr.y = NodeMatrix[i + 1];\n      newAttr = outputReducer(nodes[j], newAttr);\n      positions[nodes[j]] = {\n        x: newAttr.x,\n        y: newAttr.y\n      };\n    } else {\n      positions[nodes[j]] = {\n        x: NodeMatrix[i],\n        y: NodeMatrix[i + 1]\n      };\n    }\n\n    j++;\n  }\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n", "/**\n * Graphology ForceAtlas2 Layout Default Settings\n * ===============================================\n */\nmodule.exports = {\n  linLogMode: false,\n  outboundAttractionDistribution: false,\n  adjustSizes: false,\n  edgeWeightInfluence: 1,\n  scalingRatio: 1,\n  strongGravityMode: false,\n  gravity: 1,\n  slowDown: 1,\n  barnesHutOptimize: false,\n  barnesHutTheta: 0.5\n};\n", "/**\n * Graphology ForceAtlas2 Layout\n * ==============================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\nvar iterate = require('./iterate.js');\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign          - Whether to assign positions.\n * @param  {Graph}         graph           - Target graph.\n * @param  {object|number} params          - If number, params.iterations, else:\n * @param  {function}        getWeight     - Edge weight getter function.\n * @param  {number}          iterations    - Number of iterations.\n * @param  {function|null}   outputReducer - A node reducer\n * @param  {object}          [settings]    - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {iterations: params};\n\n  var iterations = params.iterations;\n\n  if (typeof iterations !== 'number')\n    throw new Error(\n      'graphology-layout-forceatlas2: invalid number of iterations.'\n    );\n\n  if (iterations <= 0)\n    throw new Error(\n      'graphology-layout-forceatlas2: you should provide a positive number of iterations.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(\n    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'\n  ).fromEntry;\n\n  var outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2: ' + validationError.message\n    );\n\n  // Building matrices\n  var matrices = helpers.graphToByteArrays(graph, getEdgeWeight);\n\n  var i;\n\n  // Iterating\n  for (i = 0; i < iterations; i++)\n    iterate(settings, matrices.nodes, matrices.edges);\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrices.nodes, outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrices.nodes);\n}\n\n/**\n * Function returning sane layout settings for the given graph.\n *\n * @param  {Graph|number} graph - Target graph or graph order.\n * @return {object}\n */\nfunction inferSettings(graph) {\n  var order = typeof graph === 'number' ? graph : graph.order;\n\n  return {\n    barnesHutOptimize: order > 2000,\n    strongGravityMode: true,\n    gravity: 0.05,\n    scalingRatio: 10,\n    slowDown: 1 + Math.log(order)\n  };\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\nsynchronousLayout.inferSettings = inferSettings;\n\nmodule.exports = synchronousLayout;\n", "/**\n * Graphology ForceAtlas2 Layout Webworker\n * ========================================\n *\n * Web worker able to run the layout in a separate thread.\n */\nmodule.exports = function worker() {\n  var NODES, EDGES;\n\n  var moduleShim = {};\n\n  (function () {\n    /* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmoduleShim.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n\n  })();\n\n  var iterate = moduleShim.exports;\n\n  self.addEventListener('message', function (event) {\n    var data = event.data;\n\n    NODES = new Float32Array(data.nodes);\n\n    if (data.edges) EDGES = new Float32Array(data.edges);\n\n    // Running the iteration\n    iterate(data.settings, NODES, EDGES);\n\n    // Sending result to supervisor\n    self.postMessage(\n      {\n        nodes: NODES.buffer\n      },\n      [NODES.buffer]\n    );\n  });\n};\n\n", "/**\n * Graphology ForceAtlas2 Layout Supervisor\n * =========================================\n *\n * Supervisor class able to spawn a web worker to run the FA2 layout in a\n * separate thread not to block UI with heavy synchronous computations.\n */\nvar workerFunction = require('./webworker.js');\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Class representing a FA2 layout run by a webworker.\n *\n * @constructor\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - Parameters:\n * @param  {object}          [settings] - Settings.\n */\nfunction FA2LayoutSupervisor(graph, params) {\n  params = params || {};\n\n  // Validation\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(\n    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'\n  ).fromEntry;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: ' + validationError.message\n    );\n\n  // Properties\n  this.worker = null;\n  this.graph = graph;\n  this.settings = settings;\n  this.getEdgeWeight = getEdgeWeight;\n  this.matrices = null;\n  this.running = false;\n  this.killed = false;\n  this.outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Binding listeners\n  this.handleMessage = this.handleMessage.bind(this);\n\n  var respawnFrame = undefined;\n  var self = this;\n\n  this.handleGraphUpdate = function () {\n    if (self.worker) self.worker.terminate();\n\n    if (respawnFrame) clearTimeout(respawnFrame);\n\n    respawnFrame = setTimeout(function () {\n      respawnFrame = undefined;\n      self.spawnWorker();\n    }, 0);\n  };\n\n  graph.on('nodeAdded', this.handleGraphUpdate);\n  graph.on('edgeAdded', this.handleGraphUpdate);\n  graph.on('nodeDropped', this.handleGraphUpdate);\n  graph.on('edgeDropped', this.handleGraphUpdate);\n\n  // Spawning worker\n  this.spawnWorker();\n}\n\nFA2LayoutSupervisor.prototype.isRunning = function () {\n  return this.running;\n};\n\n/**\n * Internal method used to spawn the web worker.\n */\nFA2LayoutSupervisor.prototype.spawnWorker = function () {\n  if (this.worker) this.worker.terminate();\n\n  this.worker = helpers.createWorker(workerFunction);\n  this.worker.addEventListener('message', this.handleMessage);\n\n  if (this.running) {\n    this.running = false;\n    this.start();\n  }\n};\n\n/**\n * Internal method used to handle the worker's messages.\n *\n * @param {object} event - Event to handle.\n */\nFA2LayoutSupervisor.prototype.handleMessage = function (event) {\n  if (!this.running) return;\n\n  var matrix = new Float32Array(event.data.nodes);\n\n  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);\n  if (this.outputReducer) helpers.readGraphPositions(this.graph, matrix);\n  this.matrices.nodes = matrix;\n\n  // Looping\n  this.askForIterations();\n};\n\n/**\n * Internal method used to ask for iterations from the worker.\n *\n * @param  {boolean} withEdges - Should we send edges along?\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.askForIterations = function (withEdges) {\n  var matrices = this.matrices;\n\n  var payload = {\n    settings: this.settings,\n    nodes: matrices.nodes.buffer\n  };\n\n  var buffers = [matrices.nodes.buffer];\n\n  if (withEdges) {\n    payload.edges = matrices.edges.buffer;\n    buffers.push(matrices.edges.buffer);\n  }\n\n  this.worker.postMessage(payload, buffers);\n\n  return this;\n};\n\n/**\n * Method used to start the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.start = function () {\n  if (this.killed)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker.start: layout was killed.'\n    );\n\n  if (this.running) return this;\n\n  // Building matrices\n  this.matrices = helpers.graphToByteArrays(this.graph, this.getEdgeWeight);\n\n  this.running = true;\n  this.askForIterations(true);\n\n  return this;\n};\n\n/**\n * Method used to stop the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.stop = function () {\n  this.running = false;\n\n  return this;\n};\n\n/**\n * Method used to kill the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.kill = function () {\n  if (this.killed) return this;\n\n  this.running = false;\n  this.killed = true;\n\n  // Clearing memory\n  this.matrices = null;\n\n  // Terminating worker\n  this.worker.terminate();\n\n  // Unbinding listeners\n  this.graph.removeListener('nodeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('edgeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('nodeDropped', this.handleGraphUpdate);\n  this.graph.removeListener('edgeDropped', this.handleGraphUpdate);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FA2LayoutSupervisor;\n", "import { useCallback, useRef } from \"react\";\nimport Graph from \"graphology\";\n\nimport { useSigma, isEqual } from \"@react-sigma/core\";\n\n/**\n * Generic type for Graphology layout.\n */\ninterface GraphologyLayout<T> {\n  (graph: Graph, options: T): { [node: string]: { [dimension: string]: number } };\n  assign(graph: Graph, options: T): void;\n}\n\n/**\n * Generic type for layout hooks.\n */\nexport type LayoutHook<T> = (settings?: T) => {\n  /**\n   * Returns a positions map by node key.\n   */\n  positions: () => { [node: string]: { [dimension: string]: number } };\n  /**\n   * Assign layout node's position into the sigma graph.\n   */\n  assign: () => void;\n};\n\n/**\n * Factory for layout hook.\n */\nexport function useLayoutFactory<T>(layout: GraphologyLayout<T>, defaultSettings: T): LayoutHook<T> {\n  const hook: LayoutHook<T> = (parameter: T = defaultSettings) => {\n    const sigma = useSigma();\n\n    // Default layout settings\n    const settings = useRef<T>(defaultSettings);\n    if (!isEqual(settings.current, parameter)) settings.current = parameter;\n\n    const positions = useCallback(() => {\n      if (settings.current) return layout(sigma.getGraph(), settings.current);\n      else return {};\n    }, [sigma, settings]);\n\n    const assign = useCallback(() => {\n      if (settings.current) {\n        layout.assign(sigma.getGraph(), settings.current);\n      }\n    }, [sigma, settings]);\n\n    return { positions, assign };\n  };\n\n  return hook;\n}\n", "import { useCallback, useRef, useState, useEffect } from \"react\";\nimport Graph from \"graphology\";\n\nimport { useSigma, isEqual } from \"@react-sigma/core\";\n\nexport type LayoutWorkerHook<T> = (settings: T) => {\n  stop: () => void;\n  start: () => void;\n  kill: () => void;\n  isRunning: boolean;\n};\n\ninterface GraphologyWorkerLayout {\n  stop: () => void;\n  start: () => void;\n  kill: () => void;\n}\n\ninterface GraphologyWorkerLayoutConstructor<T> {\n  new (graph: Graph, settings: T): GraphologyWorkerLayout;\n}\n\nexport function useWorkerLayoutFactory<T>(worker: GraphologyWorkerLayoutConstructor<T>): LayoutWorkerHook<T> {\n  const hook: LayoutWorkerHook<T> = (parameter: T) => {\n    const sigma = useSigma();\n    const [isRunning, setIsRunning] = useState<boolean>(false);\n    const [layout, setLayout] = useState<GraphologyWorkerLayout | null>(null);\n    const settings = useRef<T>();\n    if (!isEqual(settings.current, parameter)) settings.current = parameter;\n\n    useEffect(() => {\n      setIsRunning(false);\n      let newLayout: GraphologyWorkerLayout | null = null;\n      if (settings.current) newLayout = new worker(sigma.getGraph(), settings.current);\n      setLayout(newLayout);\n      return () => {\n        if (newLayout !== null) newLayout.kill();\n      };\n    }, [sigma, settings, setLayout, setIsRunning]);\n\n    const stop = useCallback(() => {\n      if (layout) {\n        layout.stop();\n        setIsRunning(false);\n      }\n    }, [layout, setIsRunning]);\n\n    const start = useCallback(() => {\n      if (layout) {\n        layout.start();\n        setIsRunning(true);\n      }\n    }, [layout, setIsRunning]);\n\n    const kill = useCallback(() => {\n      if (layout) {\n        layout.kill();\n      }\n      setIsRunning(false);\n    }, [layout, setIsRunning]);\n\n    return { stop, start, kill, isRunning };\n  };\n  return hook;\n}\n", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22play%22%20class%3D%22svg-inline--fa%20fa-play%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M424.4%20214.7L72.4%206.6C43.8-10.3%200%206.1%200%2047.9V464c0%2037.5%2040.7%2060.1%2072.4%2041.3l352-208c31.4-18.5%2031.5-64.1%200-82.6z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22stop%22%20class%3D%22svg-inline--fa%20fa-stop%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M400%2032H48C21.5%2032%200%2053.5%200%2080v352c0%2026.5%2021.5%2048%2048%2048h352c26.5%200%2048-21.5%2048-48V80c0-26.5-21.5-48-48-48z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "import React, { useEffect, CSSProperties } from \"react\";\n\nimport { useSigma } from \"@react-sigma/core\";\nimport { ReactComponent as StartLayoutIcon } from \"./assets/icons/play-solid.svg\";\nimport { ReactComponent as StopLayoutIcon } from \"./assets/icons/stop-solid.svg\";\nimport { LayoutWorkerHook } from \"./useWorkerLayoutFactory\";\n\ntype WorkerLayoutLabelKeys = \"start\" | \"stop\";\n\n/**\n * Properties for `WorkerLayoutControl` component\n */\nexport interface WorkerLayoutControlProps<T> {\n  /**\n   * HTML id\n   */\n  id?: string;\n\n  /**\n   * HTML class\n   */\n  className?: string;\n\n  /**\n   * HTML CSS style\n   */\n  style?: CSSProperties;\n\n  /**\n   * The layout hook to use\n   */\n  layout: LayoutWorkerHook<T>;\n\n  /**\n   * Settings of the layout.\n   */\n  settings: T;\n\n  /**\n   * Option to tell what we do when the component is mounted\n   *  - <code>-1</code> means that we do nothing (it's the same as no value)\n   *  - <code>0</code> means that we start the algo (and don't auto stop it)\n   *  - <code>X</code> mans that we start the algo, and stop it after X milliseconds\n   */\n  autoRunFor?: number;\n\n  /**\n   * It's possible to customize the button, by passing to JSX Element.\n   * First one is for the \"start layout\", and the second to \"stop layout\".\n   * Example :\n   * ```jsx\n   * <WorkerLayoutControl>\n   *   <>\n   *     <span>Start</span>\n   *     <span>Stop</span>\n   *   </>\n   * </WorkerLayoutControl>\n   * ```\n   */\n  children?: [JSX.Element, JSX.Element];\n\n  /**\n   * Map of the labels we use in the component.\n   * This is usefull for I18N\n   */\n  labels?: { [Key in WorkerLayoutLabelKeys]?: string };\n}\n\nexport function WorkerLayoutControl<T>({\n  id,\n  className,\n  style,\n  layout,\n  settings,\n  autoRunFor,\n  children,\n  labels = {},\n}: WorkerLayoutControlProps<T>) {\n  // Get Sigma\n  const sigma = useSigma();\n  // Get layout\n  const { stop, start, isRunning } = layout(settings);\n  // Common html props for the div\n  const props = {\n    className: `react-sigma-control ${className || \"\"}`,\n    id,\n    style,\n  };\n\n  /**\n   * Init component when Sigma or component settings change.\n   */\n  useEffect(() => {\n    if (!sigma) {\n      return;\n    }\n\n    // we run the algo\n    let timeout: number | null = null;\n    if (autoRunFor !== undefined && autoRunFor > -1 && sigma.getGraph().order > 0) {\n      start();\n      // set a timeout to stop it\n      timeout =\n        autoRunFor > 0\n          ? window.setTimeout(() => {\n              stop();\n            }, autoRunFor)\n          : null;\n    }\n\n    //cleaning\n    return () => {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    };\n  }, [autoRunFor, start, stop, sigma]);\n\n  return (\n    <div {...props}>\n      <button\n        onClick={() => (isRunning ? stop() : start())}\n        title={\n          isRunning ? labels[\"stop\"] || \"Stop the layout animation\" : labels[\"start\"] || \"Start the layout animation\"\n        }\n      >\n        {children && !isRunning && children[0]}\n        {children && isRunning && children[1]}\n        {!children && !isRunning && <StartLayoutIcon style={{ width: \"1em\" }} />}\n        {!children && isRunning && <StopLayoutIcon style={{ width: \"1em\" }} />}\n      </button>\n    </div>\n  );\n}\n", "import forceAtlas2, { ForceAtlas2SynchronousLayoutParameters } from \"graphology-layout-forceatlas2\";\n\nimport { useLayoutFactory } from \"@react-sigma/layout-core\";\n\n/**\n * React hook that helps you to manage [force atlas2 layout](https://graphology.github.io/standard-library/layout-forceatlas2.html).\n *\n * ```typescript\n * const { positions, assign } = useLayoutForceAtlas2(...);\n *```\n * @category Hook\n */\nexport const useLayoutForceAtlas2 = useLayoutFactory<ForceAtlas2SynchronousLayoutParameters>(forceAtlas2, {\n  iterations: 100,\n});\n", "import FA2Layout from \"graphology-layout-forceatlas2/worker\";\nimport { ForceAtlas2LayoutParameters } from \"graphology-layout-forceatlas2\";\n\nimport { useWorkerLayoutFactory } from \"@react-sigma/layout-core\";\n\n/**\n * React hook that helps you to manage worker of [force atlas2 layout](https://graphology.github.io/standard-library/layout-forceatlas2.html).\n *\n * ```typescript\n * const { stop, start } = useWorkerLayoutForceAtlas2(...);\n *```\n * @category Hook\n */\nexport const useWorkerLayoutForceAtlas2 = useWorkerLayoutFactory<ForceAtlas2LayoutParameters>(FA2Layout);\n", "import React from \"react\";\nimport { ForceAtlas2LayoutParameters } from \"graphology-layout-forceatlas2\";\n\nimport { WorkerLayoutControlProps, WorkerLayoutControl } from \"@react-sigma/layout-core\";\nimport { useWorkerLayoutForceAtlas2 } from \"./useWorkerLayoutForceAtlas2\";\n\n/**\n * Properties for `LayoutForceAtlas2Control` component\n */\nexport type LayoutForceAtlas2ControlProps = Omit<\n  WorkerLayoutControlProps<ForceAtlas2LayoutParameters>,\n  \"layout\" | \"settings\"\n> & {\n  settings?: ForceAtlas2LayoutParameters;\n};\n\n/**\n * @category Component\n */\nexport const LayoutForceAtlas2Control: React.FC<LayoutForceAtlas2ControlProps> = ({\n  id,\n  className,\n  style,\n  settings = {},\n  autoRunFor,\n  children,\n  labels,\n}) => {\n  const workerLayoutProps = { id, className, style, settings, autoRunFor, labels, layout: useWorkerLayoutForceAtlas2 };\n  return <WorkerLayoutControl {...workerLayoutProps}>{children}</WorkerLayoutControl>;\n};\n"],
  "mappings": "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",
  "names": ["v", "e", "a", "s", "t", "u", "l", "r", "n", "n2", "e", "g", "s", "l", "u", "iterate", "l", "r", "n", "n2", "e", "g", "s", "self", "useLayoutFactory", "layout", "defaultSettings", "parameter", "sigma", "useSigma", "settings", "useRef", "isEqual", "current", "positions", "useCallback", "getGraph", "assign", "useWorkerLayoutFactory", "worker", "isRunning", "setIsRunning", "useState", "setLayout", "useEffect", "newLayout", "kill", "stop", "start", "_path", "_extends", "Object", "bind", "target", "i", "arguments", "length", "source", "key", "prototype", "hasOwnProperty", "call", "apply", "this", "SvgPlaySolid", "props", "createElement", "xmlns", "className", "viewBox", "width", "height", "fill", "d", "SvgStopSolid", "WorkerLayoutControl", "id", "style", "autoRunFor", "children", "labels", "n", "timeout", "order", "window", "setTimeout", "clearTimeout", "React", "onClick", "title", "StartLayoutIcon", "StopLayoutIcon", "useLayoutForceAtlas2", "useLayoutFactory", "forceAtlas2", "iterations", "useWorkerLayoutForceAtlas2", "useWorkerLayoutFactory", "FA2Layout", "LayoutForceAtlas2Control", "id", "className", "style", "settings", "e", "autoRunFor", "children", "labels", "m", "workerLayoutProps", "layout", "React", "WorkerLayoutControl", "Object", "assign"]
}
