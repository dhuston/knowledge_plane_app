diff --git a/backend/app/main.py b/backend/app/main.py
index e004eb9..839805f 100644
--- a/backend/app/main.py
+++ b/backend/app/main.py
@@ -2,26 +2,42 @@ import logging # Import logging
 from fastapi import FastAPI, Request
 from starlette.middleware.sessions import SessionMiddleware
 from fastapi.middleware.cors import CORSMiddleware
-from starlette.responses import JSONResponse
+from starlette.responses import JSONResponse, RedirectResponse
 
 from app.core.config import settings
 from app.api.v1.api import api_router as api_v1_router
 from app.core.tenant_context import configure_tenant_middleware
 from app.core.tenant_filter import register_tenant_events
 from app.core.security import initialize_oauth
+from app.core.entity_event_hooks import register_entity_event_hooks
+
+# Configure DEBUG logging for map data to diagnose tenant issues
+logging.getLogger('app.api.v1.endpoints.map').setLevel(logging.DEBUG)
+logging.getLogger('app.crud.crud_node').setLevel(logging.DEBUG)
+logging.getLogger('app.crud.crud_edge').setLevel(logging.DEBUG)
+
+# Configure a root logger that writes to stdout for visibility
+root_logger = logging.getLogger()
+if not root_logger.handlers:
+    handler = logging.StreamHandler()
+    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
+    root_logger.addHandler(handler)
+root_logger.setLevel(logging.INFO)
 
 # Import API Routers
 from app.api.routers import auth as auth_router
 from app.api.routers import users as users_router
-from app.api.routers import teams as teams_router # Assuming this exists from Slice 1
-from app.api.routers import integrations as integrations_router # Assuming this exists
-from app.api.routers import map as map_router # New map router
-from app.api.routers import projects as projects_router # Import the new projects router
-from app.api.routers import goals as goals_router # Import goals router
+from app.api.routers import teams as teams_router
+from app.api.routers import integrations as integrations_router
+from app.api.routers import projects as projects_router
+from app.api.routers import goals as goals_router
 from app.api.routers import briefings as briefings_router
 from app.api.routers import insights as insights_router
 from app.api.routers import notes as notes_router
 from app.api.routers import stream as stream_router
+from app.api.routers import admin as admin_router
+from app.api.routers import notifications as notifications_router
+from app.api.v1.endpoints import map as map_router # v1 map router
 
 # Configure logging
 logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
@@ -46,6 +62,72 @@ async def startup_event():
     # Initialize OAuth providers
     await initialize_oauth()
     
+    # Uncomment to sync nodes and edges with entities during startup
+    # try:
+    #     logger.info("Synchronizing nodes and edges with entities...")
+    #     from scripts.sync_nodes_edges import sync_all_tenants
+    #     await sync_all_tenants()
+    #     logger.info("Node/edge synchronization complete")
+    # except Exception as e:
+    #     logger.error(f"Error during node/edge synchronization: {e}")
+    
+    # Register additional deprecated routes
+    logger.info("Registering deprecated route redirectors for backward compatibility")
+    deprecated_api_routes = [
+        # Format: (old_path, new_path)
+        ("/api/map/data", "/api/v1/map/data"),
+        ("/api/map/node/{node_type}/{node_id}", "/api/v1/map/node/{node_type}/{node_id}"),
+    ]
+    
+    # Register each deprecated route with a permanent redirect
+    for old_path, new_path in deprecated_api_routes:
+        # Use the path operations decorator directly
+        @app.get(old_path, include_in_schema=False)
+        async def redirect_deprecated_route(request: Request, node_type: str = None, node_id: str = None):
+            # Build the target path with path parameters and query params
+            target_path = new_path
+            if "{node_type}" in target_path and node_type:
+                target_path = target_path.replace("{node_type}", node_type)
+            if "{node_id}" in target_path and node_id:
+                target_path = target_path.replace("{node_id}", node_id)
+                
+            # Add query parameters if any
+            if request.url.query:
+                target_path = f"{target_path}?{request.url.query}"
+                
+            # Use absolute URL to redirect
+            target_url = f"{request.url.scheme}://{request.url.netloc}{target_path}"
+            logger.warning(f"Redirecting deprecated route from {request.url.path} to {target_path}")
+            return RedirectResponse(url=target_url, status_code=301)  # Permanent redirect
+    
+    # Log all registered routes with extremely detailed information
+    logger.info("===== REGISTERED ROUTES: DETAILED ANALYSIS =====")
+    route_paths = {}
+    for route in app.routes:
+        methods = ', '.join(getattr(route, 'methods', ['UNKNOWN']))
+        path = getattr(route, 'path', 'UNKNOWN')
+        name = getattr(route, 'name', 'unnamed')
+        handler = getattr(route, 'endpoint', None).__name__ if hasattr(getattr(route, 'endpoint', None), '__name__') else 'unknown'
+        
+        # Log individual route data
+        logger.info(f"ROUTE: '{path}' [{methods}] - {name} - handler: {handler}")
+        
+        # Track duplicate paths
+        if path in route_paths:
+            route_paths[path].append(f"{name} [{methods}] - {handler}")
+        else:
+            route_paths[path] = [f"{name} [{methods}] - {handler}"]
+            
+    # Check for duplicates and log warnings
+    logger.info("===== CHECKING FOR DUPLICATE ROUTES =====")
+    for path, handlers in route_paths.items():
+        if len(handlers) > 1:
+            logger.warning(f"DUPLICATE ROUTE: '{path}' has multiple handlers:")
+            for idx, handler in enumerate(handlers):
+                logger.warning(f"  {idx+1}. {handler}")
+        else:
+            logger.info(f"OK: '{path}' has single handler: {handlers[0]}")
+    
     logger.info("Application initialization complete")
 
 # --- Add Middlewares --- #
@@ -56,6 +138,9 @@ configure_tenant_middleware(app)
 # Register tenant filter events for SQLAlchemy
 register_tenant_events()
 
+# Register entity event hooks for graph synchronization
+register_entity_event_hooks()
+
 # Add CORS Middleware to handle preflight requests earliest
 # For development, we'll allow all origins since we're having CORS issues
 from fastapi.middleware.cors import CORSMiddleware
@@ -66,9 +151,11 @@ app.add_middleware(
     CORSMiddleware,
     allow_origins=[
         "http://localhost:5173",   # Vite dev server
+        "http://localhost:5174",   # Vite dev server (alternative port)
         "http://localhost:3000",   # React dev server 
         "http://localhost:8080",   # Alternative dev server
         "http://127.0.0.1:5173",   # Local IP variants
+        "http://127.0.0.1:5174",   # Local IP variants (alternative port)
         "http://127.0.0.1:3000"    # Local IP variants
     ],  
     allow_credentials=True,        # Enable credentials (cookies, auth headers)
@@ -78,8 +165,48 @@ app.add_middleware(
     max_age=600,                   # Cache preflight requests for 10 minutes
 )
 
-# Add the temporary logging middleware FIRST (COMMENTED OUT)
-# app.middleware("http")(log_headers_middleware)
+# Add detailed request logging middleware
+@app.middleware("http")
+async def log_request_details_middleware(request: Request, call_next):
+    """Log detailed request information to help debug routing issues."""
+    path = request.url.path
+    query = request.url.query
+    method = request.method
+    client = request.client.host if request.client else "unknown"
+    
+    # Add enhanced logging for notification endpoints
+    if "/notifications" in path:
+        logger.warning(f"NOTIFICATION REQUEST: {method} {path}?{query} - From: {client}")
+        logger.warning(f"Notification Headers: {dict(request.headers)}")
+    else:
+        logger.info(f"REQUEST: {method} {path}?{query} - From: {client}")
+        logger.info(f"Headers: {dict(request.headers)}")
+    
+    try:
+        # Time the response
+        import time
+        start_time = time.time()
+        response = await call_next(request)
+        process_time = time.time() - start_time
+        
+        # Enhanced logging for notification endpoints
+        if "/notifications" in path:
+            logger.warning(f"NOTIFICATION RESPONSE: {method} {path} - Status: {response.status_code} - Time: {process_time:.4f}s")
+        else:
+            logger.info(f"RESPONSE: {method} {path} - Status: {response.status_code} - Time: {process_time:.4f}s")
+        
+        # Check for 404s specifically with more details for notification endpoints
+        if response.status_code == 404:
+            if "/notifications" in path:
+                logger.error(f"404 NOT FOUND FOR NOTIFICATION ENDPOINT: {method} {path} - Check route registration!")
+                logger.error(f"Available routes: {[route.path for route in app.routes]}")
+            else:
+                logger.warning(f"404 NOT FOUND: {method} {path} - Check route registration!")
+            
+        return response
+    except Exception as e:
+        logger.error(f"REQUEST ERROR: {method} {path} - {str(e)}")
+        raise
 
 # Add Session Middleware 
 app.add_middleware(
@@ -90,21 +217,105 @@ app.add_middleware(
     # https_only=True, # Recommended for production
 )
 
-# Include API Routers
-# Prefix common path for all routes under this router
+# Define API routes
 api_prefix = "/api/v1"
 
+# Register the API routers
+app.include_router(map_router.router, prefix=f"{api_prefix}/map", tags=["map"])
 app.include_router(auth_router.router, prefix=f"{api_prefix}/auth", tags=["auth"])
 app.include_router(users_router.router, prefix=f"{api_prefix}/users", tags=["users"])
 app.include_router(teams_router.router, prefix=f"{api_prefix}/teams", tags=["teams"])
 app.include_router(integrations_router.router, prefix=f"{api_prefix}/integrations", tags=["integrations"])
-app.include_router(map_router.router, prefix=f"{api_prefix}/map", tags=["map"]) # Include the map router
-app.include_router(projects_router.router, prefix=f"{api_prefix}/projects", tags=["projects"]) # Register projects router
-app.include_router(goals_router.router, prefix=f"{api_prefix}/goals", tags=["goals"]) # Register goals router
+app.include_router(projects_router.router, prefix=f"{api_prefix}/projects", tags=["projects"])
+app.include_router(goals_router.router, prefix=f"{api_prefix}/goals", tags=["goals"])
 app.include_router(briefings_router.router, prefix=f"{api_prefix}/briefings", tags=["briefings"])
 app.include_router(insights_router.router, prefix=f"{api_prefix}/insights", tags=["insights"])
 app.include_router(notes_router.router, prefix=f"{api_prefix}/notes", tags=["notes"])
 app.include_router(stream_router.router, prefix=f"{api_prefix}", tags=["stream"])
+app.include_router(admin_router.router, prefix=f"{api_prefix}/admin", tags=["admin"])
+app.include_router(notifications_router.router, prefix=f"{api_prefix}/notifications", tags=["notifications"])
+
+# Log router registration details
+logger.info(f"Registered API routers at {api_prefix} including notifications router at {api_prefix}/notifications")
+
+# Add direct route handlers for debugging
+@app.get("/api/v1/map/debug-data")
+async def debug_map_data():
+    """Debug endpoint to test map data routing."""
+    logger.info("Debug map data endpoint called via /api/v1/map/debug-data")
+    return {"message": "Debug map endpoint working", "status": "success"}
+
+@app.get("/api/v1/debug-token")
+async def debug_token(request: Request):
+    """Debug endpoint to check token parsing and tenant extraction."""
+    logger.info("Debug token endpoint called")
+    
+    # Get the authorization header
+    auth_header = request.headers.get('Authorization')
+    
+    # Check if authorization header exists
+    if not auth_header or not auth_header.startswith('Bearer '):
+        return {"message": "No valid Authorization header found", "status": "error", "has_token": False}
+    
+    # Extract the token
+    token = auth_header.split(' ')[1]
+    
+    try:
+        # Decode the token
+        from app.core.security import jwt, settings, ALGORITHM
+        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
+        
+        # Extract key information
+        user_id = payload.get('sub')
+        tenant_id = payload.get('tenant_id')
+        expiration = payload.get('exp')
+        
+        # Return useful debug information
+        return {
+            "status": "success",
+            "has_token": True,
+            "user_id": user_id,
+            "tenant_id": tenant_id,
+            "token_expires": expiration,
+            "is_valid": True
+        }
+    except Exception as e:
+        logger.error(f"Error decoding token: {str(e)}")
+        return {
+            "status": "error",
+            "has_token": True,
+            "error": str(e),
+            "is_valid": False
+        }
+
+# Direct map/data endpoint for fallback
+@app.get("/map/data")
+async def direct_map_data(request: Request):
+    """Direct fallback map data endpoint."""
+    logger.info("Direct map data endpoint called via /map/data")
+    # Redirect to the correct endpoint
+    logger.info(f"Redirecting request from /map/data to /api/v1/map/data")
+    # Use absolute URL to redirect
+    url = f"{request.url.scheme}://{request.url.netloc}/api/v1/map/data{f'?{request.url.query}' if request.url.query else ''}"
+    return RedirectResponse(url=url)
+
+# Direct map/node endpoint for fallback
+@app.get("/map/node/{node_type}/{node_id}")
+async def direct_map_node(request: Request, node_type: str, node_id: str):
+    """Direct fallback for node endpoint."""
+    logger.info(f"Direct map node endpoint called via /map/node/{node_type}/{node_id}")
+    # Redirect to the correct endpoint
+    logger.info(f"Redirecting request from /map/node/{node_type}/{node_id} to /api/v1/map/node/{node_type}/{node_id}")
+    # Use absolute URL to redirect
+    url = f"{request.url.scheme}://{request.url.netloc}/api/v1/map/node/{node_type}/{node_id}{f'?{request.url.query}' if request.url.query else ''}"
+    return RedirectResponse(url=url)
+
+# Direct map/debug-data endpoint for fallback
+@app.get("/map/debug-data")
+async def direct_debug_map_data():
+    """Direct fallback debug endpoint."""
+    logger.info("Direct debug endpoint called via /map/debug-data")
+    return {"message": "Direct debug map endpoint working", "status": "success", "route": "/map/debug-data"}
 
 # Add root endpoint or additional setup if needed
 @app.get("/")
@@ -128,11 +339,6 @@ async def dev_login(request: Request):
     """Development-only endpoint that returns mock tokens directly without OAuth redirect"""
     logger.info("Development login endpoint accessed")
     
-    # Only allow in development mode
-    if not getattr(settings, "DISABLE_OAUTH", False):
-        from fastapi import HTTPException
-        raise HTTPException(status_code=404, detail="Not found")
-        
     # Generate mock tokens
     from app.core.security import create_access_token
     from uuid import UUID
@@ -154,6 +360,9 @@ async def dev_login(request: Request):
         expires_delta=timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
     )
     
+    # Log the tokens - IMPORTANT: Only do this in development/debug environments!
+    logger.info(f"Generated dev login tokens - access_token: {access_token[:15]}..., refresh_token: {refresh_token[:15]}...")
+    
     # Create the response with tokens
     response = JSONResponse({
         "access_token": access_token,
@@ -209,4 +418,21 @@ async def mock_me(request: Request):
         
     except Exception as e:
         logger.error(f"Token validation error: {e}")
-        return JSONResponse({"detail": "Invalid or expired token"}, status_code=401)
\ No newline at end of file
+        return JSONResponse({"detail": "Invalid or expired token"}, status_code=401)
+
+
+# Add debug endpoints for troubleshooting the notifications system
+@app.get("/api/v1/notifications/debug")
+async def debug_notifications_endpoint():
+    """Debug endpoint for notifications."""
+    logger.warning("Debug notifications endpoint called")
+    return {"message": "Debug notifications endpoint is working", "status": "success"}
+
+@app.get("/notifications/preferences")
+async def direct_notification_preferences(request: Request):
+    """Direct fallback endpoint for notification preferences."""
+    logger.warning("Direct notification preferences endpoint accessed at /notifications/preferences")
+    # Redirect to the correct endpoint
+    url = f"{request.url.scheme}://{request.url.netloc}/api/v1/notifications/preferences{f'?{request.url.query}' if request.url.query else ''}"
+    logger.warning(f"Redirecting to: {url}")
+    return RedirectResponse(url=url)
\ No newline at end of file
